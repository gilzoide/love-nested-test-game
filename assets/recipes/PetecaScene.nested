p1x: `WINDOW_WIDTH * 0.25`
p2x: `WINDOW_WIDTH * 0.75`
py: `WINDOW_HEIGHT - R('Player').radius`
petecaX: `WINDOW_WIDTH * 0.5`
petecaY: 120
metersByPixel: 60

gamepaused: false
gameover: true
pauseGame: `do
    self.gamepaused = not self.gamepaused
    if self.gamepaused then
        score:showPaused()
    else
        score:hide()
    end
end`

options: { R options.save }
toggleMusic: `do
    BGM.playing = options.MUSIC
end`

preinit: `do
    love.physics.setMeter(metersByPixel)
end`

init: `do
    love.graphics.setBackgroundColor(0.12, 0.12, 0.12)
    self:reset()
end`

reset: `do
    peteca.body.position = { petecaX, petecaY }
    peteca.body.angle = 0
    peteca.body.angularVelocity = 0
    peteca.body.linearVelocity = { 0, 0.1 }
    peteca.lastToHit = nil

    player1.body.position = { p1x, py }
    player1.body.linearVelocity = { 0, 0.1 }
    player1.body.angle = 0
    player1.body.angularVelocity = 0
    player1:reset()

    player2.body.position = { p2x, py }
    player2.body.linearVelocity = { 0, 0.1 }
    player2.body.angle = 0
    player2.body.angularVelocity = 0
    player2:reset()
end`

[AudioSource id: BGM
    source: { R 'Stack - fase.ogg' }
    playing: `options.MUSIC` looping: true
]

[World id: WORLD yg: `9.81 * metersByPixel`
    paused: `root.gamepaused or root.gameover`

    [Arena id: arena]
    [Player id: player1 color: [0 1 0]
        goingLeft: `ACTION.p1left.down`
        goingRight: `ACTION.p1right.down`
        otherPlayer: `player2`
    ]
    [Player id: player2 color: [1 1 0] flipX: true
        goingLeft: `ACTION.p2left.down`
        goingRight: `ACTION.p2right.down`
        otherPlayer: `player1`
    ]
    [Peteca id: peteca x: `petecaX` y: `petecaY`]

    [CollisionTracker a: [tag: PETECA] b: [tag: GROUND]
        beginContact: { peteca.lastToHit.otherPlayer.takingDamage: true  }
        endContact:   { peteca.lastToHit.otherPlayer.takingDamage: false }
        postSolve: `do peteca:impulse(contact:getNormal()) end`
    ]
    [CollisionTracker a: [tag: PETECA] b: [tag: RACKET]
        postSolve: { a.root.lastToHit: b.root }
    ]
    [CollisionTracker a: [tag: PETECA] b: [tag: BODY]
        beginContact: { b.root.takingDamage: true  }
        endContact:   { b.root.takingDamage: false }
    ]
]

[InputMap id: ACTION
    keycode: [
        p1left: a
        p1right: d
        p2left: left
        p2right: right
        pause: return
        toggle_music: m
    ]
    gamepad: [
        [ #1
            p1left: dpleft
            p1right: dpright
            p2left: x
            p2right: b
            pause: start
        ]
    ]
]

[LifeBar anchor: [0 0 0 0.4] margin: [10 10] height: 15
    color: `player1.color`
    maxLife: `player1.maxLife`
    currentLife: `player1.currentLife`
    takingDamage: `player1.takingDamage`
]
[Transform x: `WINDOW_WIDTH` sx: -1 sy: 1
    [LifeBar color: `player2.color`
        anchor: [0 0 0 0.4] margin: [10 10] height: 15
        maxLife: `player2.maxLife`
        currentLife: `player2.currentLife`
        takingDamage: `player2.takingDamage`
    ]
]

[Score id: score]

[OptionsMenu id: OPTIONS_MENU paused: `gameover`
    ontogglemusic: `root.toggleMusic`
    ontogglecollapse: `do
        local self, collapsing = ...
        root:pauseGame(not collapsing)
    end`
]

[When
    player1.gameover: `do
        self.gameover = true
        score:showWinner(2)
    end`

    player2.gameover: `do
        self.gameover = true
        score:showWinner(1)
    end`

    '!gameover, ACTION.pause.pressed': `do
        OPTIONS_MENU:toggleCollapsed()
    end`

    'gameover, ACTION.pause.pressed': `do
        self:reset()
        score:hide()
        self.gameover = false
    end`

    'ACTION.toggle_music.pressed': `do OPTIONS_MENU.MUSIC:toggle() end`
]

